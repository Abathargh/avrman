## device implements some useful stuff for device discovery on various
## platforms.
## One thing I always wanted with this kind of libraries, was to automate
## everything regarding the loading and discovery process, so that's what this
## is about, a generic mechanism for device and pid/vid retrieval.

import std/[dirs, json, os, sequtils, strformat, strutils, sets, sugar, tables]

## a target must define ‘enumerate_serial_devices‘ and ‘get_vid_pid‘

when defined(linux):
  include device_linux
elif defined(macosx):
  include device_macosx
else:
  type UnsupportedException = object of Exception
  iterator enumerate_serial_devices(): seq[string] =
    raise new_exception(UnsupportedException, "unsupported platform")

  proc get_vid_pid(dev: string): tuple[vid: uint16, pid: uint16] =
    raise new_exception(UnsupportedException, "unsupported platform")


type
  Device* = object ## \
  ## Device descriptor for a programmer or a board that can be programmed.
    name*:     string
    protocol*: string
    mcu*:      string
    ids*:      Table[uint16, OrderedSet[uint16]]
    speed*:    int
    freq*:     int
    flush*:    bool

  FlashTarget* = enum ## \
  ## Flash targets for discovery generation purposes, these are the underlying
  ## config files that can be generated by the tool.
    Nimble
    Make


const
  # discovery variables for nimble/make tasks
  c_port   = "DEV_PORT"
  nim_port = "dev_port"

  # discovery blocks for nimble/make tasks
  c_disc   = fmt"{c_port}=$$(shell avrman device -p $#)"
  nim_disc = fmt"""
  let ({nim_port}, code) = gorge_ex("avrman device -p $#")
  if code != 0:
    echo {nim_port}
    return
  """


proc generate_progstr*(dev: Device, port: string = "",
                       target: FlashTarget = Nimble): string =
  ## Generates the prog string for avrdude, that will contain all the needed
  ## information to perform the programming. Some parts of this string are
  ## contained within the nimble templates, as they are not to be customized.
  ## The user can pass a port, to disable port discovery and hard-code what
  ## port is desired, and can specify a target for code generation.

  result = fmt"-c {dev.protocol} -p {dev.mcu}"

  if dev.speed != 0: result.add fmt" -b {dev.speed}"
  if dev.flush:      result.add fmt" -D"

  if port == "":
    case target
    of Nimble: result.add fmt""" -P " & {nim_port} & """"
    of Make:   result.add fmt" -P $({c_port}) "
  else:
    result.add fmt" -P {port}"


proc find_port*(dev: Device): string =
  ## Finds the port tied to the device, if correctly initialized, returns an
  ## empty string if nothing is found.
  for port in enumerate_serial_devices():
    let (vid, pid) = get_vid_pid(port)
    if vid in dev.ids and pid in dev.ids[vid]:
      return port
  ""


proc generate_discovery*(dev: Device, target: FlashTarget = Nimble): string =
  ## Generates the discovery string for a a nimble or make/cmake task, so that
  ## the flahs targets defined in those files can discover the board when
  ## being executed.
  if dev.name == "": # early exit: this cannot be a discoverable device
    return ""

  case target
  of Nimble:
    nim_disc % [dev.name]
  of Make:
    c_disc   % [dev.name]

proc parse_ids(node: JsonNode): Table[uint16, OrderedSet[uint16]] =
  for key, val in node.pairs:
    var vid = key.parse_hex_int.uint16
    for pid in val:
      if vid notin result: result[vid] = initOrderedSet[uint16]()
      result[vid].incl pid.get_str.parse_hex_int.uint16


proc parse_dev(node: JsonNode): Device =
  # mandatory fields
  result.name      = get_str   node["name"]
  result.protocol  = get_str   node["protocol"]
  result.ids       = parse_ids node["id_map"]

  # non-mandatory fields
  result.mcu       = get_str( node.get_or_default("mcu"), "")
  result.freq      = get_int( node.get_or_default("frequency"), 0)
  result.speed     = get_int( node.get_or_default("speed"), 0)
  result.flush     = get_bool(node.get_or_default("dis_flush"), false)


const devices = (proc(): Table[string, Device] =
  let boards = "device/boards.json".read_file.parse_json
  let progs  = "device/programmers.json".read_file.parse_json
  for board in boards:
    let jboard = board.parse_dev
    let tname  = jboard.name.to_lower_ascii.replace("-", "")
    result[tname] = jboard

  for prog in progs:
    let jprog = prog.parse_dev
    let tname = jprog.name.to_lower_ascii.replace("-", "")
    result[tname]  = jprog
)()


# The following two here are just a const sequence of the names of the device
# above, and a const concatenated version of the same, to print with
# avrman device -l, for convenience

const
  supported_names = collect(initHashSet()):
    for name in devices.keys:
      {name}

  supported_names_str* = supported_names.to_seq.join("\n")


proc levenshtein(s1, s2: string): int =
  var supp = newSeq[seq[int]](s1.len + 1)
  for i in 0..s1.len:
    supp[i] = newSeq[int](s2.len + 1)

  for i in 0..s1.len:
    supp[i][0] = i

  for j in 0..s2.len:
    supp[0][j] = j

  for i in 1..s1.len:
    for j in 1..s2.len:
      if s1[i - 1] != s2[j-1]:
        let minimum = min(min(supp[i][j-1], supp[i-1][j]), supp[i-1][j-1])
        supp[i][j] = minimum + 1
      else:
        supp[i][j] = supp[i-1][j-1]

  supp[s1.len][s2.len]


proc closest_guess*(name: string): string =
  ## Returns the closest device name to the passed name.
  var min_name = ""
  var min_len  = int.high

  let normalized_name = name.to_lower_ascii.replace("-", "")

  for device_name in supported_names:
    let distance = levenshtein(normalized_name, device_name)
    if distance < min_len:
      min_name = device_name
      min_len = distance
  min_name


proc is_supported*(dev_name: string): bool =
  ## Returns true if the device identified by `dev_name` is supported by the
  ## tool.
  dev_name.to_lower_ascii.replace("-", "") in supported_names


proc get_device*(dev_name: string): Device =
  ## Returns the device handle if the device identified by `dev_name` is
  ## supported by the tool. Use with `is_supported`, may raise `KeyError`.
  let name = dev_name.to_lower_ascii.replace("-", "")
  devices[name]
